#!/bin/bash
# =============================================================================
# et-update - EmComm-Tools Safe Update System
# Version: 1.0.0
# Updated: 2026-01-10
# Author: Sylvain Deguire (VA2OPS)
#
# Safe atomic update with automatic rollback on failure
# =============================================================================

set -e

# Paths
ET_HOME="/opt/emcomm-tools"
ET_CONF="${ET_HOME}/conf/update.conf"
ET_MANIFEST="${ET_HOME}/manifest.json"
ET_BACKUP_DIR="${ET_HOME}/backup"
ET_TEMP_DIR="/tmp/et-update-$$"
ET_LOCK_FILE="/var/lock/et-update.lock"
ET_LOG_FILE="/var/log/emcomm-tools/update.log"
ET_TRANSACTION_LOG="${ET_TEMP_DIR}/transaction.log"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# =============================================================================
# Logging Functions
# =============================================================================
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Console output (to stderr so it doesn't interfere with function returns)
    case "$level" in
        INFO)  echo -e "${GREEN}[INFO]${NC} $message" >&2 ;;
        WARN)  echo -e "${YELLOW}[WARN]${NC} $message" >&2 ;;
        ERROR) echo -e "${RED}[ERROR]${NC} $message" >&2 ;;
        DEBUG) [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[DEBUG]${NC} $message" >&2 ;;
    esac
    
    # File output
    mkdir -p "$(dirname "$ET_LOG_FILE")"
    echo "[$timestamp] [$level] $message" >> "$ET_LOG_FILE"
}

transaction_log() {
    local action="$1"
    local file="$2"
    local status="$3"
    echo "$(date '+%Y-%m-%d %H:%M:%S')|$action|$file|$status" >> "$ET_TRANSACTION_LOG"
}

# =============================================================================
# Lock Management
# =============================================================================
acquire_lock() {
    if [ -f "$ET_LOCK_FILE" ]; then
        local pid=$(cat "$ET_LOCK_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            log ERROR "Another update is running (PID: $pid)"
            exit 1
        else
            log WARN "Stale lock file found, removing..."
            rm -f "$ET_LOCK_FILE"
        fi
    fi
    echo $$ > "$ET_LOCK_FILE"
    trap cleanup EXIT
}

release_lock() {
    rm -f "$ET_LOCK_FILE"
}

cleanup() {
    release_lock
    rm -rf "$ET_TEMP_DIR"
}

# =============================================================================
# Configuration
# =============================================================================
load_config() {
    if [ ! -f "$ET_CONF" ]; then
        log ERROR "Configuration file not found: $ET_CONF"
        exit 1
    fi
    source "$ET_CONF"
    
    if [ "$UPDATE_ENABLED" != "true" ]; then
        log INFO "Update system is disabled in configuration"
        exit 0
    fi
}

# =============================================================================
# Checksum Functions
# =============================================================================
calculate_sha256() {
    local file="$1"
    sha256sum "$file" | cut -d' ' -f1
}

verify_checksum() {
    local file="$1"
    local expected="$2"
    local actual=$(calculate_sha256 "$file")
    
    if [ "$actual" == "$expected" ]; then
        return 0
    else
        log ERROR "Checksum mismatch for $file"
        log ERROR "  Expected: $expected"
        log ERROR "  Actual:   $actual"
        return 1
    fi
}

# =============================================================================
# Download Functions
# =============================================================================
download_file() {
    local url="$1"
    local dest="$2"
    local expected_sha256="$3"
    
    log DEBUG "Downloading: $url"
    
    if ! wget -q -O "$dest" "$url"; then
        log ERROR "Download failed: $url"
        return 1
    fi
    
    if [ -n "$expected_sha256" ]; then
        if ! verify_checksum "$dest" "$expected_sha256"; then
            rm -f "$dest"
            return 1
        fi
    fi
    
    return 0
}

download_manifest() {
    local url="${UPDATE_URL}/${UPDATE_CHANNEL}/manifest.json"
    local dest="${ET_TEMP_DIR}/manifest-remote.json"
    
    # Ensure temp directory exists
    mkdir -p "$ET_TEMP_DIR"
    
    log INFO "Fetching update manifest..."
    
    if ! download_file "$url" "$dest"; then
        log ERROR "Failed to download manifest from $url"
        return 1
    fi
    
    # Check file exists and has content
    if [ ! -s "$dest" ]; then
        log ERROR "Downloaded manifest is empty"
        return 1
    fi
    
    # Validate JSON
    if ! jq empty "$dest" 2>/dev/null; then
        log ERROR "Invalid manifest JSON"
        return 1
    fi
    
    echo "$dest"
}

# =============================================================================
# Comparison Functions
# =============================================================================
compare_manifests() {
    local remote_manifest="$1"
    local updates_file="${ET_TEMP_DIR}/updates.json"
    
    if [ ! -f "$ET_MANIFEST" ]; then
        log WARN "No local manifest found, all files will be downloaded"
        cp "$remote_manifest" "$updates_file"
        jq '.files' "$updates_file"
        return 0
    fi
    
    # Compare and find files that need updating
    jq -n --slurpfile remote "$remote_manifest" --slurpfile local "$ET_MANIFEST" '
        $remote[0].files as $rf |
        ($local[0].files // []) as $lf |
        [
            $rf[] |
            . as $r |
            ($lf | map(select(.path == $r.path)) | .[0]) as $l |
            if $l == null then
                $r + {"action": "new"}
            elif $l.sha256 != $r.sha256 then
                $r + {"action": "update", "old_version": $l.version}
            else
                empty
            end
        ]
    ' > "$updates_file"
    
    cat "$updates_file"
}

# =============================================================================
# Backup Functions
# =============================================================================
create_backup() {
    local file_path="$1"
    local full_path="${ET_HOME}/${file_path}"
    local backup_date=$(date '+%Y-%m-%d_%H%M%S')
    local backup_path="${ET_BACKUP_DIR}/${backup_date}"
    local backup_file="${backup_path}/${file_path}"
    
    if [ ! -f "$full_path" ]; then
        log DEBUG "No existing file to backup: $file_path"
        return 0
    fi
    
    mkdir -p "$(dirname "$backup_file")"
    
    log DEBUG "Backing up: $file_path"
    
    # Copy (not move!) to preserve original until install succeeds
    if ! cp -p "$full_path" "$backup_file"; then
        log ERROR "Failed to create backup: $file_path"
        return 1
    fi
    
    # Verify backup
    local original_sha=$(calculate_sha256 "$full_path")
    local backup_sha=$(calculate_sha256 "$backup_file")
    
    if [ "$original_sha" != "$backup_sha" ]; then
        log ERROR "Backup verification failed: $file_path"
        return 1
    fi
    
    transaction_log "BACKUP" "$file_path" "OK"
    echo "$backup_file"
}

cleanup_old_backups() {
    local keep=${BACKUP_KEEP:-3}
    local backup_dirs=$(ls -dt "${ET_BACKUP_DIR}"/*/ 2>/dev/null | tail -n +$((keep + 1)))
    
    for dir in $backup_dirs; do
        log INFO "Removing old backup: $dir"
        rm -rf "$dir"
    done
}

# =============================================================================
# Install Functions
# =============================================================================
install_file() {
    local temp_file="$1"
    local dest_path="$2"
    local permissions="$3"
    local full_dest="${ET_HOME}/${dest_path}"
    
    mkdir -p "$(dirname "$full_dest")"
    
    # Atomic move (same filesystem)
    if ! mv "$temp_file" "$full_dest"; then
        log ERROR "Failed to install: $dest_path"
        return 1
    fi
    
    # Set permissions
    chmod "$permissions" "$full_dest"
    
    # Verify installation
    if [ ! -f "$full_dest" ]; then
        log ERROR "Installation verification failed: $dest_path"
        return 1
    fi
    
    transaction_log "INSTALL" "$dest_path" "OK"
    return 0
}

restore_from_backup() {
    local file_path="$1"
    local backup_file="$2"
    local full_dest="${ET_HOME}/${file_path}"
    
    log WARN "Restoring from backup: $file_path"
    
    if [ -f "$backup_file" ]; then
        cp -p "$backup_file" "$full_dest"
        transaction_log "RESTORE" "$file_path" "OK"
    else
        log ERROR "No backup available for: $file_path"
        transaction_log "RESTORE" "$file_path" "FAILED"
    fi
}

# =============================================================================
# Main Update Logic
# =============================================================================
do_update() {
    local dry_run="$1"
    
    mkdir -p "$ET_TEMP_DIR"
    touch "$ET_TRANSACTION_LOG"
    
    # Download remote manifest
    local remote_manifest
    remote_manifest=$(download_manifest)
    local download_status=$?
    
    if [ $download_status -ne 0 ] || [ -z "$remote_manifest" ] || [ ! -f "$remote_manifest" ]; then
        log ERROR "Failed to get remote manifest"
        return 1
    fi
    
    # Compare manifests
    log INFO "Comparing versions..."
    local updates=$(compare_manifests "$remote_manifest")
    local update_count=$(echo "$updates" | jq 'length' 2>/dev/null || echo "0")
    
    if [ "$update_count" -eq 0 ] || [ "$update_count" = "null" ]; then
        log INFO "System is up to date!"
        return 0
    fi
    
    log INFO "Found $update_count file(s) to update"
    
    # Show what will be updated
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║  Files to update:                                                ║"
    echo "╠══════════════════════════════════════════════════════════════════╣"
    echo "$updates" | jq -r '.[] | "║  \(.action): \(.path) → v\(.version)"' | while read line; do
        printf "%-70s║\n" "$line"
    done
    echo "╚══════════════════════════════════════════════════════════════════╝"
    echo ""
    
    if [ "$dry_run" == "true" ]; then
        log INFO "Dry run complete. No changes made."
        return 0
    fi
    
    # Confirm with user
    if [ "$AUTO_UPDATE" != "true" ]; then
        read -p "Proceed with update? (y/N): " confirm
        if [ "${confirm,,}" != "y" ]; then
            log INFO "Update cancelled by user"
            return 0
        fi
    fi
    
    # Get base URL from remote manifest
    local base_url=$(jq -r '.base_url' "$remote_manifest")
    local backup_date=$(date '+%Y-%m-%d_%H%M%S')
    local failed=false
    
    # Process each file
    echo "$updates" | jq -c '.[]' | while read file_info; do
        local path=$(echo "$file_info" | jq -r '.path')
        local version=$(echo "$file_info" | jq -r '.version')
        local sha256=$(echo "$file_info" | jq -r '.sha256')
        local permissions=$(echo "$file_info" | jq -r '.permissions // "644"')
        local action=$(echo "$file_info" | jq -r '.action')
        
        log INFO "Processing: $path (v$version)"
        
        # Phase 1: Download
        local temp_file="${ET_TEMP_DIR}/${path}"
        mkdir -p "$(dirname "$temp_file")"
        
        if ! download_file "${base_url}/${path}" "$temp_file" "$sha256"; then
            log ERROR "Download failed for: $path"
            failed=true
            break
        fi
        transaction_log "DOWNLOAD" "$path" "OK"
        
        # Phase 2: Backup (if file exists)
        local backup_file=""
        if [ "$action" == "update" ]; then
            backup_file=$(create_backup "$path")
            if [ $? -ne 0 ]; then
                failed=true
                break
            fi
        fi
        
        # Phase 3: Install
        if ! install_file "$temp_file" "$path" "$permissions"; then
            log ERROR "Install failed for: $path"
            if [ -n "$backup_file" ]; then
                restore_from_backup "$path" "$backup_file"
            fi
            failed=true
            break
        fi
        
        # Phase 4: Final verification
        local installed_sha=$(calculate_sha256 "${ET_HOME}/${path}")
        if [ "$installed_sha" != "$sha256" ]; then
            log ERROR "Final verification failed for: $path"
            if [ -n "$backup_file" ]; then
                restore_from_backup "$path" "$backup_file"
            fi
            failed=true
            break
        fi
        
        log INFO "✓ Updated: $path (v$version)"
    done
    
    if [ "$failed" == "true" ]; then
        log ERROR "Update failed! Check logs for details."
        log ERROR "Transaction log: $ET_TRANSACTION_LOG"
        return 1
    fi
    
    # Update local manifest
    cp "$remote_manifest" "$ET_MANIFEST"
    
    # Update last check time
    sed -i "s/^LAST_CHECK=.*/LAST_CHECK=$(date '+%Y-%m-%d')/" "$ET_CONF"
    
    # Cleanup old backups
    cleanup_old_backups
    
    log INFO "Update complete!"
    return 0
}

# =============================================================================
# Command Line Interface
# =============================================================================
show_help() {
    cat << EOF
EmComm-Tools Update System

Usage: et-update [OPTIONS] [COMMAND]

Commands:
  check       Check for updates without installing
  update      Download and install updates (default)
  status      Show current version and update status
  history     Show update history

Options:
  -y, --yes       Auto-confirm updates (no prompt)
  -n, --dry-run   Show what would be updated without making changes
  -v, --verbose   Show detailed output
  -h, --help      Show this help message

Examples:
  et-update                  # Check and install updates
  et-update check            # Check for updates only
  et-update --dry-run        # Preview updates
  et-update -y               # Update without prompting

EOF
}

show_status() {
    load_config
    
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║  EmComm-Tools Update Status                                      ║"
    echo "╠══════════════════════════════════════════════════════════════════╣"
    
    if [ -f "$ET_MANIFEST" ]; then
        local version=$(jq -r '.version' "$ET_MANIFEST")
        local release_date=$(jq -r '.release_date' "$ET_MANIFEST")
        printf "║  Installed Version: %-47s║\n" "$version"
        printf "║  Release Date:      %-47s║\n" "$release_date"
    else
        echo "║  No manifest found - version unknown                             ║"
    fi
    
    printf "║  Update Channel:    %-47s║\n" "$UPDATE_CHANNEL"
    printf "║  Update URL:        %-47s║\n" "$UPDATE_URL"
    printf "║  Last Check:        %-47s║\n" "$LAST_CHECK"
    printf "║  Update Enabled:    %-47s║\n" "$UPDATE_ENABLED"
    echo "╚══════════════════════════════════════════════════════════════════╝"
}

# =============================================================================
# Main
# =============================================================================
main() {
    local command="update"
    local dry_run="false"
    VERBOSE="false"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            check)
                command="check"
                shift
                ;;
            update)
                command="update"
                shift
                ;;
            status)
                command="status"
                shift
                ;;
            history)
                command="history"
                shift
                ;;
            -y|--yes)
                AUTO_UPDATE="true"
                shift
                ;;
            -n|--dry-run)
                dry_run="true"
                shift
                ;;
            -v|--verbose)
                VERBOSE="true"
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log ERROR "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Load configuration
    load_config
    
    # Acquire lock for update operations
    if [ "$command" == "update" ] || [ "$command" == "check" ]; then
        acquire_lock
    fi
    
    # Execute command
    case $command in
        status)
            show_status
            ;;
        check)
            dry_run="true"
            do_update "$dry_run"
            ;;
        update)
            do_update "$dry_run"
            ;;
        history)
            if [ -d "$ET_BACKUP_DIR" ]; then
                echo "Available backups:"
                ls -lt "$ET_BACKUP_DIR" 2>/dev/null || echo "No backups found"
            else
                echo "No backup history found"
            fi
            ;;
    esac
}

main "$@"
